# Notes

Notes are written for my own understanding so these may be inappropriate for others to understand. But I tried to write in a way so any begineer can understand.

## 01Into

- Jargons being used in golang
  - literal value = an untyped numeric constant like 42, 3.14
  - untyped = If the value declaration on the right hand side is not the typed then it is untyped
  - typed = any value of data type (int, bool etc)
  - Standard type sizes (unless developer has specific needs)
    - int
    - unint
    - float64
    - complex128
  - Casting a float to an integer truncates the floating point portion.
  - default native types:
    - int
    - unint
    - float64
    - complex128
    - string
    - bool
    - byte
    - rune
  - constants cant use the := (short) declaration syntax.
    - the value can't be changed once it has been declared.
  - Whenever any data comes from the web it's actually in the byte format and we have to wrap it around string, so in that case, we are just converting the byte into string.
    - But, sometimes we don't want to do that (like converting bytes into string) instead we want to consume the data as it is in JSON format.

### Syntax stuff
- Same line declarations
  - floatNumber, text := 3.14, "Hello World
- Some types can be converted in this way:
  - yearsInSchool := 2.4
  - yearsInSchoolInt := int(yearsInSchool)
  - Casting a float to an integer truncates the floating point portion.



- Create directory named 01Into
- Open this in "Integrated terminal"
- Execute "go mod init hello" -> it will initialize a module named "hello" as well as create go.mod file.
- Create main.go file.
- Write "package main" (on top of file)
- to print the hello world:
  - initialize function with:
        func main(){ fmt.Println("Hello World")}
  - fmt is a package in golang
  - Println is a method
  - adding fmt in function will import "fmt" package (in golang, we don't need to import packages manually)
- go help -> for go documentation and find out the command etc.
  - go run help -> it will specifically come up with the help related to "run" command
  - go env GOPATH -> to know more about env variable for go.
  - environment variable path for windows: C:\Users\%USERPROFILE%\go
- lexer
  - is who knows the grammer of language like where to put semicolon and where it should not etc.
  - this is something who can add/remove semicolon at the end of the line. for example:
    - we can put semicolon at the end of line 6 (before curely braces) in main.go file but lexer will remove that semicolon because we've installed intellisence from go language.
- types
  - case insensitive - almost everything in go language
  - Everything is type in golang.
  - first initial letter of type gives idea about whether the type is public or private. for example, Println function.
  - const LoginName string -> this capital 'L' in variable (LoginName) declares that it is public and available across the files and program.
  - This Println function was written in a way that it can be used publically. Some other functions that help to this Println are not exposed publically.
  - Similar to other languages, go also has types for example, string, bool, integr, float, complex
  - some advance types: array, slices, maps, structs, pointers
- User Input
  - to take an input from user (or from keyboard), in golang we need to have some packages which are bufio and os.
  - buffer i/o will help to buffer the i/o and os package will help to get the input from user (or from keyboard)
  - syntax:
    - reader := bufio.NewReader(os.Stdin)
      - reader -> variable
      - := -> operator for assignment and declaration
      - bufio -> go package (buffer) which can read from input/output so we can read from keyboard, from printers and other resources.
      - NewReader -> method of bufio package -> public because of first letter is capital.
      - But, from where we should be reading up? to answer the question, we added os.Stdin.
      - os -> go package (this is another library to interect with OS.)
      - Stdin -> method of os package.
    - As soon as we save the file with above syntax, it will import both libraries(packages) (bufio and os)
    - till above syntax, a process is going on to read the input (is syntax tak koi na koi process read kar raha hai.)
    - whatever this (reader var) reads, we want to store it into a variable (called input (in line 51)) but here comes "comma ok || err ok" syntax into play.
  - comma ok syntax || err err
  - syntax
    - input, _ := reader.ReadString('\n')
      - input -> whatever an input will be given
      - _ -> (underscore) means, if any mistake/error occurs during input so this is something try catch.
      - we can write "err" instead of "_(underscore)" but its fine.
      - reader -> is a variable we declared above
      - .ReadString -> is a method which will wait (or read) for string we gonna input.
      - ('\n') -> represents new line so reader.ReadString will read for string till we press "Enter".
  - Why we put input, _?
    - It is expected that, when reading something (from Stdin (standard input) for example) there might be chances of something might go wrong, and for that wrong thing there might be an error comes in. In that case, we can go and store just like this "input, err" (this might give an error because we may not be using it but this is how golang syntax works)
    - So, this is something like "comma ok || err err" syntax.
    - If everything goes right, it will give me input.
    - If any wrong happens then it will through an error.
- Conversion
  - to convert the string into integer, we have strconv library in golang (as I know till the time of writing these notes)
  - Syntax
    - numRating, err := strconv.ParseFloat(strings.TrimSpace(input), 64)
      - numRating -> new variable so we can see conversion in action.
      - err -> the variable we discussed above in "comma ok || err err" syntax
      - strconv.ParseFloat -> ParseFloat is a property of strconv function which takes two arguments, string and bit size (which is 64 in the case of Float)
      - strings.TrimSpace()
        - strings is also a powerfull package in golang which has so many features for example ToLower, Map, TrimSpace etc
        - TrimSpace() is a function which will trim spaces.
          - Remember we used '\n' in reader.ReadString('\n') to read the input till we press enter.
          - so, when we type any number and press enter then this is not just a number but a trailing(\ character) as well which is being used here. so to remove the trailing or any space or any first character, we used this TrimSpace() function.
          - So, TrimSpace() will trim this (\n) character and convert it into Float.
        - strings.TrimSpace(input) -> this is an argument (s string) of ParseFloat function.
      - 64 -> is a bit size and 2nd argument of ParseFloat.
- Random Numbers
  - there are two packages
    - math/rand
    - crypto/rand
  - math/rand
    - this package can generate random numbers but not guranteed as not governed by good algorithm for random numbers.
    - sometimes it returns the same number unless you use Seed with rand package i.e. rand.Seed()
    - It will keep generating same number unless you change number in Seed.
    - The range we define in rand function is always exclusive. for example if we define range as '5' then the number will be generated from 0 to 4 and not 5.
    - Syntax:
      - fmt.Println(rand.Intn(5))
      - above syntax will always return the same number between 1 and 4.
        - Why?
          - because in golang it considers that nothing is random in Computer hence everything is driven by algorithm.
          - Some programs, some methods and some algorithm are written by somebody.
          - Hence this algorithm is written by Seed (rand.Seed())
          - We have to change the number in Seed so it will give us random number. But this is not something we want to achieve.
        - How we can achive the random number using math/rand?
          - The only thing which keep on changing is time (no matter what you do).
          - Now, it is much guranteed that the Seed (rand.Seed()) is being initialized by a truely random number (every single time) and we are expected to get the random number.
        - Syntax
          - rand.Seed(time.Now().UnixNano())
          - fmt.Println(rand.Intn(5))
    - crypto/rand
      - this packages gives us surety about randomness of number because it goverened by a cryptograpghy algorithm.
      - We can use this package to generate secure information for example token etc.
        - Syntax
          - randomNum, _ := rand.Int(rand.Reader(), big.NewInt(5))
          - fmt.Println(randomNum)
- time
  - we need to use time package to use and format time in golang
  - time.Now()
  - Syntax
    - presentTime := time.Now()
    - fmt.Println(presentTime)
  - Formatting time:
    - to format the time, we need to use 'Format' method.
      - fmt.Println(presentTime.Format("2006-01-02 15:04:05 Monday"))
      - 2006-01-02 15:04:05 Monday ->
        - 2006 -> will always represent to current year (in output)
        - 01 -> will represent to Month
        - 02 -> will represent to Date
        - Monday -> will represent to Current Day
        - Output -> 2022-01-13 Thursday
        - 15 -> current Hour
        - 04 -> minute
        - 05 -> second
    - How to create a Date with formatting:
      - Syntax
        - createdDate := time.Date(2021, time.December, 03, 07, 00, 00, 00, time.Local)
        - time.Date() -> function to be used for creating Date in golang
        - year -> is an integer
        - month -> comes from time package and it has to be used only with time. for example time.December
        - day -> int. for example 03
        - hour -> int. 07
        - minute -> int. 00
        - second -> int. 00
        - nano second -> int 00
        - location -> time.Local (time.UTC) - different formats available.
- Memory Management
  - It handle automatically in golang.
  - It has two functions new() and make()
  - Both functions accepts data types such that pointer, array, slice etc
  - new() works with zeroed storage which means it does not accept any value initially. In simple word, we cannot store anything initially in new() function.
  - new() cannot be initialized initially
  - make() accept storage
  - make() can be initiallized
- GC - Garbage collection
  - ...
- Pointers
  - Pointer is a reference to the direct memory location, something like this 0xc0000b2008 etc
  - When we create any variable or constant, it gets stored in a location in memory and takes some space into memory.
  - When we call this variable/constant then sometimes it's reference passed on instead of actual value.
  - Why we need pointers:
    - Sometimes we have to be guranteed that actual value should be passed on and not the reference. It may comes up with some kind of irregularities in code.
    - So to avoid such kind of irregularities, we use __Pointers__.
  - __In Simple words__
    - A Pointer is nothing, it's just a direct reference to a memory address and since we are directly passing an address it makes 100% gurantee that actual value is being passed on.
  - Syntax:
    - var ptr *int
      - var -> keyword
      - ptr -> var name
      - *int -> this integer is of type integer which means it will store integer value in this pointer.
    - myNumber := 23
    - var ptr := &myNumber
      - & (amp sign) -> it means we are not just initializing a var but also referencing an initialized var.
      - So whenever there is a talk about "reference" then we will use "& (sign)".
      - myNumber := 26 -> Initializing var and assigned value to it.
      - var ptr = &myNumber -> Re-initializing var with already initialized variable. But this time referencing with & sign
      - fmt.Println("Value of ptr is", ptr) -> It will print the direct location of memory (or memory address) of variable
      - fmt.Println("Value of ptr is", *ptr) -> The value inside this //*ptr (pointer) will be 26.
        - When I put *ptr, it means I want to see what's inside that pointer?
        - How I was able to fill that?
        - I was able to fill that by adding a reference to &myNumber.
        - *ptr means it's not memory address. It's an actual value inside of it which is 26 in our case.
  - Pointer gives us the gurantee that the operation will be performed on Actual value.
- Array
  - Syntax
    - var fruitList [4]string
      - var -> keyword
      - fruitList -> var name
      - [4] -> Length of array, such that elements to be in Array.
      - string -> data type
      - var fruitList [4]string -> here, we just declared an array but not initialized.
      - fruitList[0] = "Apple" -> here, we initialized the array with value.
      - fruitList[1] = "Mango"
      - fruitList[3] = "Orange"
      - In above case, it will print 3 values in sequence (FruitList is:  [Apple Peach  Mango]) notice the space between Peach and Mango. This is because of index 2 that we left to initialize and its keep printing the value of it.
      - We can only print those elements that we defined during variable declaration.
    - var vegeList = [3]string{"Potato","Mushrom","Tomato"}
    - fmt.Println("Elements in vegeList", len(vegeList))
    - fmt.Println(len(vegeList[0]))
- Slices in golang
  - Main difference in between array and slices is if we are defining a value in sqaure braces then it means a simple array for example:
    - var list = [4]string
  - If we dont define values there then it means this is "slices". for example
    - var list = []string
      - If we are using this syntax then we must initialized it as well for example
        - var list = []string{"Apple", "Mango", "Banana"}
  - Array was defined very precisely and we cannot assign value more than we defined in array.
  - In Slices, we can add many values as we like and it keeps expand memory for us.
  - Syntax:
    - var sliceList = []string{"Apple", "Mango", "Banana"}
    - Notice the difference. We didn't add elements in square braces above.
  - Slice will return following type:
    - []string
- How to append any element in existing array:
  - In slices, we have append function which requires some arguments. for example:
    - sliceList = append(sliceList, "Peach","Orange")
- Slicing in slice (array)
  - colon (:) between two elements slice up the slice. In simple words, if you want to make a separate part of slice then use colon (:)
  - Range is always non-inclusive in golang which means it does not include in result.
  - Syntax:
    - sliceList = append(sliceList[1:])
      - In result, it will start from the first elemnent which is Apple. But Apple is at the zeroed index of array.
    - sliceList = append(sliceList[1:3])
      - Array elements -> [Apple Mango Banana Peach Orange]
      - It will start from Mango because 0 is not counted here...
      - Second element is Banana
      - Third element is Peach but it will not be printed because the last range is always non-inclusive, that's why Peach will not be printed.
- Remove item from slice based on index
  - First we need to declare index number that we want to remove
  - then we need to write :(colon) syntax that we used before to add items in slice
  - Syntax
    - [javascript Java C# golang swift] -> slice items
    - var index int = 2
      - We want the value on index number 2 to be deleted
    - cources = append(cources[:index], cource[index+1:]...)
      - :index -> start from default value which is on 0th position and go to index(th) position which is C#. This is not inclusive.
      - It will start from javascript, take java and leave C#
      - cource[index+1:] -> start from index+1 (2+1=3) which means golang...and go till end
      - ... : not sure about these 3 dots at the moment.
  - In simple words, to remove an item from array (or slice) we can delete that item by skipping it.
- Maps in golang
  - Maps also known as hash table or key value pairs in some languages.
  - We can use make() to create whether it is slice or map. for example:
    - languages := make()
  - Syntax:
    - abbreviations := make(map[string]string)
    - make() -> is a function that handles memory management.
      - it can accept storage which means it wont give errors with non-zeroed storage
      - map[string]string -> map is data type which we must define when starting working with maps in golang
      - [string]string -> first string represents the key
      - string -> this second string represents the value
    - initialize variable:
    - abbreviations["JS"] = "JavaScript"
    - it will print "map[JS:JavaScript OS:OperatingSystem PS:PowerShell]"
- Delete key value pair from map in golang
  - Syntax:
    - delete(abbreviations, "JS") -> it requires only key to remove the pair from map.
- Structs in golang
  - Structs is an alternative of class because golang doesn't have classes.
  - No inheritance in golang.
  - No parent child concept do exist in golang.
  - How do we define struct in golang?
    - First, we need to define the structure and then can utilize it anywhere in different ways.
    - Syntax:
      - type User struct {}
      - type -> first we use a keyword "type"
      - User -> notice the first letter that is capital which means publicaly available. It also means that since it is an alternative of class so similarly it can be exported.
      - struct -> here we are saying that I want to define the structure.
      - {} -> curly braces to define the structure.
- Note about structs
  - Make sure the following:
    - There is no inheritance in golang
    - The first letter of element in structure should be upper-case (with capital letters) so it can be exported and accessed by anyone.
- If/Else in golang
  - We can write if/else logic on the go. 
  - for example:
    - initialize and assign value to variable
    - check if/else. for example
    - if num := 3 , num > 3
- Switch Case
- Loops in golang
  - golang has only one type of loop which is for-loop
  - basic syntax to understand the loops (basic for loop)
    - for initialization; condition; post{
       // statements....}
      - The initialization statement is optional and executes before for loop starts. The initialization statement is always in a simple statement like variable declarations, increment or assignment statements, or function calls.
      - The condition statement holds a boolean expression, which is evaluated at the starting of each iteration of the loop. If the value of the conditional statement is true, then the loop executes.
      - The post statement is executed after the body of the for-loop. After the post statement, the condition statement evaluates again if the value of the conditional statement is false, then the loop ends.
  - It's good to define a data structure which we want to loop through on.
  - Best option is to define slice as below:
    - days := []string{"Saturday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday"}
    - for d := 0; d < len(days); d++{
    - fmt.Println(days[d])}
      - d -> is similar to 'i' we have been working when defining loop in different languages.
        - so here, d is equal to 0
      - d < len(days) -> run the loop till the value in 'd' is less than the values defined in slice (days)
        - so, here we have all elements in len(days).
      - d := 0; d < len(days)
        - loop will start from 0
        - 0 < 7 (0 is less then 7)
      - d++
        - d = 0+1
        - print the value from d(th) position which will be Saturday in first run.
        - so, I want to print out whats the value of days at the present d, means 0th position, 1st position, 2nd position etc
  - for loop in writing style of while loop
    - num := 0
    - for i < 5 {
      - fmt.Println(i)
      - num++
    - }
  - break in loops
    - is actually imediatly exits the loop.
    - it doesn't look for what after the break is in curely braces.
    - it also exits the loop even the condition is staisfying.
    - in simple words: exits and goes to the end.
  - continue in loops
    - it imediatly jumps to beginning of the loop and skip rest of the statements.
    - in simple words: jumps back right to the beginning.
- functions in golang
  - Basic syntax:
    - func main(){}
    - main is an entry point in golang
    - as soon as we create main function we don't even need to call it and can execute the file (go run main.go)
    - because golang knows that main is an entry point.
  - Function inside the function is not allowed.
    - It will throw an error saying "expression is expected and not function"
    - but in once case, it is allowed: when we assign func to a variable. See a complete example in [main.go](00practice/main.go)
      - func main(){
      - test := func(){
        - fmt.Println("hello world")
      - }
      - test()
      - }
  - ... (three triple dots) are variadic functions and they can expect any values.
  - When we call any function then it direclty jumps to the function declaration, performs operation and return back to the line where it jumped from.
  - We write function to resue it and avoid copy pasting code etc.
  - We can have multiple parameters in function call even with different data types, for example:
    - func add(num1 int, num2 int){}
    - func add (num1 int, name string){}
  - function declaration
    - func add(num1 int, num2 int){
    - fmt.Println(num1 + num2)}
      - We need to pass stuff as parameter if we want any operation to be performed using this function.
      - We also need to define it's type, i.e. int, string, float64 etc
      - fmt.Println(num1 + num2) -> in this function, we want to add two numbers
  - function call
    - add(5,5)
      - in Function call, we just need to pass value as comma separated. Do not put any operand in function call for example +, -, * (multiply) etc
  - variadic function
    - sometimes we dont know how many values are going to come in to function call, hence we cannot define it as an argument.
    - for example: in this case, we know two values are there in function declaration. Syntax:
      - func add(num1 int, num2 int) int {return num1 + num2}
      - add(5,5) 
    - In order to support this case, we can variadic function, for example:
      - refer to folder 15functions for example.
    - This is similar to append method in slices.
  - return keyword (returning result)
    - Sometimes instead of priting the result we want to hold it and use later on or manipulate them.
    - If we are not willing to get things done directly in function declaration then we can simply pass the result to someone else to perform certain operation on behalf of us.
    - we need to use return keyword in function declaration.
    - we also need to add type of value that we want to return
      - for example if we want to return 'int' then we need to define 'int' after parantheses (and before curly braces)
        - Syntax of return
          - func add(num1 int, num2 int) int {
            - return num1 + num2
          - }
          - ans := add(5,5)
          - fmt.Println(ans)
    - if we are returning two data types then we need to enclosed both types in parantheses as below:
      - func data(num1 int, name string) (int, string){}
  - We can omit data type and define only once if parameters are of the same data type. for example:
    - func add(num1, num2 int){}
  - label our return value
    - We can lable return values in golang
    - Syntax:
      - func add(num1, num2 int) (lbl1 int){
      - lbl1 = num1 + num2
      - return
      - }
      - In this case, I dont need to write something like this: return num1 + num2 because we've labled our return variable.
- Difference between Method and function
  - function -> when we do regular things and waraped up that is called function.
  - Method -> Since golang does not have classes so when these functions go into the classes (or struct in golang) then it is called method.
- Methods in golang
  - Because of not having classes in golang, we need to bring our functions into structs so we can call them methods.
  - to create a method we should have sturct that we can pass on to method as object. for example:
  - func (u User) method_name(){}
    - u -> representing to an object (or struct) which is User
    - User -> is a struc we've defined in 11structs file.
  - Basic syntax
    - see line 19 in [16method.go file](/16methods/main.go)
  - Important notes
    - Whenever we pass on these objects (or structs) it actually passes on a copy, here comes the concept of pointers in golang
    - So to pass the original object, we should be passing up the reference of it (or a pointer to that).
- Defer in golang
  - defer means "to postpone" or in Urdu "Muakhar karna"
  - code executes line by line in golang
  - defer is a keyword in golang.
  - defer means, it delays the execution of code (line) that has defer with it. for example:
    - func main(){
      - defer fmt.Println("World")
      - fmt.Println("Hello")
      - }
      - This "world will get jump this line 389 to very end of the block before curly braces.
      - So, it will print, Hello, World.
  - In reverse order, it works like "LIFO" (last in first out)
  - More examples and notes added in [17defer.go file](/17defer/main.go)
  - As soon as we see 'defer' then execution of it will get little delay.
- Working with files in golang
  - Using built-in packages, we can only read txt file in golang
  - to read/write csv file, we need external package
  - We need following items in order to perform read/write operations in golang
    - content
    - create file
    - read file
  - Packages we need to use for "working with file in golang"
    - os
      - os.Create 
        - -> to create the file
        - -> it requires one argument, file name(file path) which has to create.
    - io
      - io.WriteString 
        - -> to write string in file
        - -> it requires two arguments, file and content
    - ioutil
      - ioutil.ReadFile 
      - -> to read the file
      - It requires one argument which is file data
- Handling web request in golang
  - This is about, How we can make a request to URL
  - Whenever we send a request to any web server (or website), it returns with a response object.
    - So, to handle this web request and response we use net/http package in golang.
    - http package has so many functions, types and methods etc to work with it.
    - We will start with GET
    - If we want to handle response object then we need to use type "Response" with http package.
  - Close (this is a type in http package)
    - Whenever we make a new request to any website, it is our responsibility to close the connection because neither ReadResponse nor Response.Write does this.
  - At this stage,
    - First of all, we need to define a url in global space
    - In most cases, there is a separate function for this request handling so we can use it anywhere but at this stage we're gonna write the code in 'main' function.
  - Type of response
    - Type of response is *http.Response which is a pointer. Having the type of response is pointer means, we will get an original value and not the copy of it.
  - ioutil
    - Previously in file handling, we used ioutil with ReadFile (like this ioutil.ReadFile) but in response handling, we will use ioutil.ReadAll
    - Majority of the reading is done by ioutil package (it's majority and not all)
    - After reading response, we also need to convert it to string
- URL handling in golang
  - We do have "url" library in golang to work with url handling
  - Parsing means we want to extract some information from the url (in context meaning)
    - When we do Parsing on a URL then there comes up so many details from that url.
    - Syntax:
      - url.Parse() -> pass url as an argument
  - Constructing URL
    - We can also construct url if we already have values for example, protocol, host, port, path etc
    - In this case, we must need to pass the reference of url. This is very important. For example
      - partsOfUrl := &url.URL{} -> this is the syntax of constructing url.
  - Two important packages:
    - url.Parse() this (.Parse()) function parses the url. for example url.Parse(url)
    - parsedUrl.Query() this (.Query()) function helps us to extract the query parameters in a format of key value pair.
    - partsOfUrl.String() -> this (.String()) will construct the url with the values provided in &url.URL{}
    - See this [main.go](/20urlhandling/main.go) for code.
- Web Request with Get Method
  - string is a data type
  - strings is a package in golang
  - ioutil.ReadAll(response.Body)
    - We use ioutil to read the body of response. This is of type "byte" hence we do convert it into string.
- Web Request with POST Method
  - We do mostly sends the data either in json format or in url-encoded forms.
  - http.Post
    - This method requires some parameters
      - url -> whatever the url it is there
      - data type -> string or json...
        - if it's json then -> make sure it should be something like this "application/json"
      - content/data -> request body
  - Create fake json payload
    - Syntax:
      - requestBody := strings.NewReader(`
      - {
        - "name":"Zeeshan"
        - "age": 32
        - "website":"https://acloudtechie.com"
      - }`)
- Web Request with Postform
  - In this request, we are gonna send form data with our request
  - Method to be used for this:
    - url.Values
      - .Values -> is the method to be used to work with post form request.
    - Syntax:
      - url.Values{} -> initially keep the defination empty so later values can be assigned to it.
      - data := url.Values{} -> first assign the value to variable.
      - data.Add() -> use Add method to add fake values.
- Create Json Data in golang
  - encoding of json:
    - it means, we have the data in any format, either it is slices, string or int. We need to convert it into json that is called encoding in this section.
  - json.Marshal() 
    - .Marshal() is used to encode the data in json format.
    - it requires one parameter which is struct
  - json.MarshallIndent() 
    - It will indent the content in proper format and not in single line.
    - it requires three parameters:
      - struct (interface)
      - prefix (it could be empty string) "" -> this will add in all lines of output so if there is something else then it will print similar to this.
      - "\t" -> this is for tab, similar to \n for new line
  - To encode data in JSON format:
    - First we need to define data structure
    - Second we need to create the data that has to be package as JSON
    - Third package the data in JSON format
  - Creating alias of Keys in data structure (struct)
    - Syntax:
      - type Profile struct {}
        - This can accepts parameters for example
          - Name string -> string is one parameter
        - Now, If we want to create an alias of this name so it prints alias and not the actual key then we need to add another parameter something like this:
          - Name string `json:"fullname"` (followed with back tick and json keyword)
          - head over to [this](/22encodingjson/main.go) file from line number 16 to 23
    - Important note:
      - If your API contains some sensitive information and you want to omit this for people consuming your APIs then we can do something like this in our struct:
        - Password string `json:"-"`
          - This will omit Password key and it's value to be printed in output.
      - omitempty
        - what this means is if any value is empty(or nil) in against a key in struct then it will not be printed out. for example:
          - tags []string
            - If someone didn't provide the value and only provided 'nil' then it will print "null" in output
          - tags []string `json:"tags,omitempty"`
            - Above will not print any value which were not provided as struct's value.
            - See [here](/22encodingjson/main.go) for complete code.
- Create Json Data in golang
  - Decoding JSON data
    - It means, how we can consume the JSON data.
      - In many cases, JSON data will come to us as an API resource or from any other backend.
      - We should be able to consume that JSON data.
      - But, before consuming it, we need to decode it
    - First thing: we should have JSON data. (at this stage)
  - First of all we need to check either the json data is valid or not. Use this function:
    - json.Valid(data)
  - Second, if/else to check if json is valid or not:
    - if valid, then json.Unmarshal(), it accepts two parameters: jsonData, interface
      - jsonData -> the data available to use in json format
      - interface -> another name of struct, so we need to put struct here
      - Make sure to pass reference of structure and not the copy
        - json.UnMarshal(jsonDataFromFile, &userData)
        - See [DecodeJSON()](/challengeExercises/profile_v1.go) function for example
  - Print decoded json data:
    - fmt.Printf("%#v\n", struct)
      - %#v -> this is special format to print struct's value that is coming from structure