# Notes

Notes are written for my own understanding so these may be inappropriate (or detailed) for others. However, I tried to write in a way so any begineer can understand.

## 01Intro

- Jargons being used in golang
  - literal value = an untyped numeric constant like 42, 3.14
  - untyped = If the value declaration on the right hand side is not the typed then it is untyped
  - typed = any value of data type (int, bool etc)
  - Standard type sizes (unless developer has specific needs)
    - int
      - int -> signed integers
      - it contains both positive and negative numbers
    - unint
      - uint -> unsigned integer
      - which means only positive number including 0
    - float64
    - complex128
  - Casting a float to an integer truncates the floating point portion.
  - default native types:
    - int
    - unint
    - float64
    - complex128
    - string
    - bool
    - byte
    - rune
  - constants cant use the := (short) declaration syntax.
    - the value can't be changed once it has been declared.
  - static typed
    - In static typed, we compiler throws an error when data is mismatched with type. for example, we defined two integers and then called one from them as integer and another as string.
    - C++, C, Java comes under this category.
  - dynamic typed
    - We don't need to define it's data type for example int, string or bool etc
    - It is also called loosly type. JavaScript, Python and PHP comes under this category
  - Golang as static and dynamic
    - golang works with static typed but sometimes it also refers to as dynamic type.
  - Format specifier
    - It tell golang about how to format different types of data types.
      - %v is used to format the value in a default format.
      - %d is used to format decimal integers var grades int = 42; fmt.Printf("Marks are %d", grades)
      - %s is used for normal string
      - %T is used for type of the value
      - %f is used for floating number
      - %t is used for boolean value
      - %c is used for character
      - %q is used to format quoted string
  - Variable scope:
    - Outer vs inner block
      - Outer block cannot access variable that is defined in inner block, hence a variable defined in inner block cannot be accessd via outer block.
      - for example [main.go](00notesexample/main.go)
  - Local vs Global variables
    - Local
      - those variables that are declared inside a function or block is termed as local variable.
      - those variables are not accessible outside of block of function
      - those can be used and declared in loops and conditions
    - Global
      - for example [main.go](00notesexample/main.go)
  - zero values
    - when we declare any variable but not initialzed it. This comes with default value which is known as zero value.
  - User Input
    - Scanf
      - this function is part of fmt package.
      - It takes input according to variable, it's data type and format specifier.
      - this function requires input sequentially. for example, if .1st variable is int and second is string then in function call we must keep the same sequence.
      - variable in scanf statment must be with & (& sign) which is a reference to make sure the actual value is being stored in variable.
        - fmt.Scanf("%f\n", &weight)
        - to take input from multiple lines, i.e. by pressing enter then define the syntax as below:
          - fmt.Scanf("%s\n", &variableName)
          - "\n" will send the cursor to next line
      - Scanf function requires two arguements, count and err
        - count - will return the count of successful execution
        - err - will throw an error (if any)
        - rerfer to this file [main.go](00notesexample/scanf.go)
  - Find data type
    - %T
      - this is a format specifier that is used to find the type of variable
      - fmt.Printf("Type of variable is %T",variable)
    - reflect.TypeOf()
      - this function returns the type of both value and it's variable
  - Constants
    - typed
      - when we explicitly assign a type to constant, for example const name string = "Zeeshan"
    - untyped
      - when the type is infered by compiler at runtime. for example const age = 32
    - A value cannot be changed once it is initialiezed with constant.
    - We cannot declare constant without value hence Zero or null value does not apply here
    - We cannot declare constant with shothand syntax such that const name := "Zeeshan". It will throw an error

  - Operators in golang
    - comparison
      - == != < => <= >
    - arithmetic
      - addition(+) subtraction(-) multiplication(*) division(/) modulus(%) increament(++) decreament(--)
      - We can use addition operator on string.
      - We cannot use subtraction operator on string as it will throw an error.
      - Subtraction works well with number.
      - division operator returns the qoutient when left operand is divided by right operand. var a,b int = 24,2 (we get the qoutient as 12 because 24 is divided by 12)
      - modulus returns the "reminder" when the left operand is divided by right operand.
      - increment operator is a unary operator. Unary operators are the operators that act upon a single operand to produce a new value. var i int = 1; i++
    - logical
      - This checks the logic between two expressions.
      - && (logical and), || (logical OR), ! (logical not)
      - && returns true when both left and right side are true
      - || returns true when one of them is true and return false when both sides are false
      - ! reverse the results. For example if expression returns true then it will reverse it to false.
    - assignment
      - = -> assign
        - var number int = 10
      - += -> add and assign
        - it assigns left operand with the addition result.
        - x+= y means, x = x + y
      - -= -> substract and assign
        - x-= y means, x = x - y
      - *= -> multiply and assign
        - x*= y means, x = x * y
      - /= -> divide and assign qoutient
        - x/= y means, x = x / y
      - %= -> divide and assign modulus
        - x%= y means, x = x % y
    - bitwise
      - It is different than other operators
      - It works at bit level
      - It performs bit by bit operations
        - & (bitwise AND)
          - It takes two numbers as operand and does AND operations on every bit of two numbers.
          - In simple words, this operations performs on binary format because it works at bit level.
          - In AND case, it checks the bit of one number and the corresponding bit of second number.
            - We get 1 if both bit of two operands is 1.
            - We get 0 If one of the bit of two operands is 0 or 1.
            - Example:
              - var num1, num2 = 10,22
              - 0 0 0 0 1 0 1 0 -> binary representation
	            - 0 0 0 1 0 1 1 0 -> binary representation
              - result := num1 & num2
              - fmt.Println(result)
              - output -> 2
        - | (bitwise OR)
          - It takes two numbers as operand and perform OR operations on every bit of two numbers.
          - We get 1 with even if one bit of two operands is 1.
          - We get 0 when both bit of two operands are 0.
            - Example:
              - var num1, num2 int = 10, 22
	            - 0 0 0 0 1 0 1 0
	            - 0 0 0 1 0 1 1 0
	            - bitwiseAND := num1 & num2
	            - bitwiseOR := num1 | num2
	            - fmt.Println(bitwiseOR)
	            - output -> 30
        - ^ (bitwise XOR)
          - It takes two numbers as operand and perform XOR operations on every bit of two numbers.
          - We get 1 if two bits are opposite
          - We get 0 if both of the two bits are same.
            - Example:
              - var num1, num2 int = 10, 22
              - 0 0 0 0 1 0 1 0
              - 0 0 0 1 0 1 1 0
              - bitwiseXOR := num1 ^ num2
              - fmt.Println(bitwiseXOR)
              - output -> 28
        - << (left shift)
          - It shifts all bits towards left by a certain number of specified bits.
            - For example, we have 212 = 11010100
            - when we shift all bits towards left by 1 then it will be:
              -  11010100 -> 212
              - 110101000 -> 424
          - The bit positions that have been vacated by the left shift operator are filled with 0.
          - example is in the [bitwise.go](00notesexample/bitwise.go)
          - Example:
            - var num1, num2 int = 10, 22
            - bitwiseXOR := num1 ^ num2
            - fmt.Println(bitwiseXOR)
            - bitwiseLeftShift := bitwiseXOR << 1
            - fmt.Println(bitwiseLeftShift)
            - output -> 56
        - >> (right shift)
          - It shift all bits towards right by a certain number of specified bits.
          - excess bits shifted off to the right are discarded.
          - Example:
            - 0 0 0 1 0 1 1 0 -> 22
            - bitwiseRightShift := 22 >> 2
            - fmt.Println("bitwise right shift", bitwiseRightShift)
            - output -> 5
  - if-else statement (control flow)
  - switch-case
    - fallthrough
      - It is a keyword used in switch-case
      - It forces the execution flow to fall through the successive case block.
        - jis case k sath ye keyword hoga wo next case block ko execute kardega...ye isi tarah chalta rahega until it found "default" keyword or not found fallthrough keyword. 
    - 
  - Whenever any data comes from the web it's actually in the byte format and we have to wrap it around string, so in that case, we are just converting the byte into string.
    - But, sometimes we don't want to do that (like converting bytes into string) instead we want to consume the data as it is in JSON format.
  - Rune is an alias of int32. This emphasis that an integer represents to code point.
    - code point -> ASCII define every character with a number which ranges from 0-127 so total 128.
    - These are identified as code points. It covers English letters, latin numbers and a few other characters.
      - fmt.Println([]byte("Héllo"))
      - fmt.Println([]rune("Héllo"))

### Syntax stuff
- Same line declarations
  - floatNumber, text := 3.14, "Hello World"
- Some types can be converted in this way:
  - yearsInSchool := 2.4
  - yearsInSchoolInt := int(yearsInSchool)
  - Casting a float to an integer truncates the floating point portion.


- Create directory named 01Into
- Open this in "Integrated terminal"
- Execute "go mod init hello" -> it will initialize a module named "hello" as well as create go.mod file.
- Create main.go file.
- Write "package main" (on top of file)
- to print the hello world:
  - initialize function with:
        func main(){ fmt.Println("Hello World")}
  - fmt is a package in golang
  - Println is a method
  - adding fmt in function will import "fmt" package (in golang, we don't need to import packages manually)
- go help -> for go documentation and find out the command etc.
  - go run help -> it will specifically come up with the help related to "run" command
  - go env GOPATH -> to know more about env variable for go.
  - environment variable path for windows: C:\Users\%USERPROFILE%\go
- lexer
  - is who knows the grammer of language like where to put semicolon and where it should not etc.
  - this is something who can add/remove semicolon at the end of the line. for example:
    - we can put semicolon at the end of line 6 (before curely braces) in main.go file but lexer will remove that semicolon because we've installed intellisence from go language.
- types
  - case insensitive - almost everything in go language
  - Everything is type in golang.
  - first initial letter of type gives idea about whether the type is public or private. for example, Println function.
  - const LoginName string -> this capital 'L' in variable (LoginName) declares that it is public and available across the files and program.
  - This Println function was written in a way that it can be used publically. Some other functions that help to this Println are not exposed publically.
  - Similar to other languages, go also has types for example, string, bool, integr, float, complex
  - some advance types: array, slices, maps, structs, pointers
- User Input
  - to take an input from user (or from keyboard), in golang we need to have some packages which are bufio and os.
  - buffer i/o will help to buffer the i/o and os package will help to get the input from user (or from keyboard)
  - syntax:
    - reader := bufio.NewReader(os.Stdin)
      - reader -> variable
      - := -> operator for assignment and declaration
      - bufio -> go package (buffer) which can read from input/output so we can read from keyboard, from printers and other resources.
      - NewReader -> method of bufio package -> public because of first letter is capital.
      - But, from where we should be reading up? to answer the question, we added os.Stdin.
      - os -> go package (this is another library to interect with OS.)
      - Stdin -> method of os package.
    - As soon as we save the file with above syntax, it will import both libraries(packages) (bufio and os)
    - till above syntax, a process is going on to read the input (is syntax tak koi na koi process read kar raha hai.)
    - whatever this (reader var) reads, we want to store it into a variable (called input (in line 51)) but here comes "comma ok || err ok" syntax into play.
  - comma ok syntax || err err
  - syntax
    - input, _ := reader.ReadString('\n')
      - input -> whatever an input will be given
      - _ -> (underscore) means, if any mistake/error occurs during input so this is something try catch.
      - we can write "err" instead of "_(underscore)" but its fine.
      - reader -> is a variable we declared above
      - .ReadString -> is a method which will wait (or read) for string we gonna input.
      - ('\n') -> represents new line so reader.ReadString will read for string till we press "Enter".
  - Why we put input, _?
    - It is expected that, when reading something (from Stdin (standard input) for example) there might be chances of something might go wrong, and for that wrong thing there might be an error comes in. In that case, we can go and store just like this "input, err" (this might give an error because we may not be using it but this is how golang syntax works)
    - So, this is something like "comma ok || err err" syntax.
    - If everything goes right, it will give me input.
    - If any wrong happens then it will through an error.
- Conversion
  - to convert the string into integer, we have strconv library in golang (as I know till the time of writing these notes)
  - Syntax
    - numRating, err := strconv.ParseFloat(strings.TrimSpace(input), 64)
      - numRating -> new variable so we can see conversion in action.
      - err -> the variable we discussed above in "comma ok || err err" syntax
      - strconv.ParseFloat -> ParseFloat is a property of strconv function which takes two arguments, string and bit size (which is 64 in the case of Float)
      - strings.TrimSpace()
        - strings is also a powerfull package in golang which has so many features for example ToLower, Map, TrimSpace etc
        - TrimSpace() is a function which will trim spaces.
          - Remember we used '\n' in reader.ReadString('\n') to read the input till we press enter.
          - so, when we type any number and press enter then this is not just a number but a trailing(\ character) as well which is being used here. so to remove the trailing or any space or any first character, we used this TrimSpace() function.
          - So, TrimSpace() will trim this (\n) character and convert it into Float.
        - strings.TrimSpace(input) -> this is an argument (s string) of ParseFloat function.
      - 64 -> is a bit size and 2nd argument of ParseFloat.
- Random Numbers
  - there are two packages
    - math/rand
    - crypto/rand
  - math/rand
    - this package can generate random numbers but not guranteed as not governed by good algorithm for random numbers.
    - sometimes it returns the same number unless you use Seed with rand package i.e. rand.Seed()
    - It will keep generating same number unless you change number in Seed.
    - The range we define in rand function is always exclusive. for example if we define range as '5' then the number will be generated from 0 to 4 and not 5.
    - Syntax:
      - fmt.Println(rand.Intn(5))
      - above syntax will always return the same number between 1 and 4.
        - Why?
          - because in golang it considers that nothing is random in Computer hence everything is driven by algorithm.
          - Some programs, some methods and some algorithm are written by somebody.
          - Hence this algorithm is written by Seed (rand.Seed())
          - We have to change the number in Seed so it will give us random number. But this is not something we want to achieve.
        - How we can achive the random number using math/rand?
          - The only thing which keep on changing is time (no matter what you do).
          - Now, it is much guranteed that the Seed (rand.Seed()) is being initialized by a truely random number (every single time) and we are expected to get the random number.
        - Syntax
          - rand.Seed(time.Now().UnixNano())
          - fmt.Println(rand.Intn(5))
    - crypto/rand
      - this packages gives us surety about randomness of number because it goverened by a cryptograpghy algorithm.
      - We can use this package to generate secure information for example token etc.
        - Syntax
          - randomNum, _ := rand.Int(rand.Reader(), big.NewInt(5))
          - fmt.Println(randomNum)
- time
  - we need to use time package to use and format time in golang
  - time.Now()
  - Syntax
    - presentTime := time.Now()
    - fmt.Println(presentTime)
  - Formatting time:
    - to format the time, we need to use 'Format' method.
      - fmt.Println(presentTime.Format("2006-01-02 15:04:05 Monday"))
      - 2006-01-02 15:04:05 Monday ->
        - 2006 -> will always represent to current year (in output)
        - 01 -> will represent to Month
        - 02 -> will represent to Date
        - Monday -> will represent to Current Day
        - Output -> 2022-01-13 Thursday
        - 15 -> current Hour
        - 04 -> minute
        - 05 -> second
    - How to create a Date with formatting:
      - Syntax
        - createdDate := time.Date(2021, time.December, 03, 07, 00, 00, 00, time.Local)
        - time.Date() -> function to be used for creating Date in golang
        - year -> is an integer
        - month -> comes from time package and it has to be used only with time. for example time.December
        - day -> int. for example 03
        - hour -> int. 07
        - minute -> int. 00
        - second -> int. 00
        - nano second -> int 00
        - location -> time.Local (time.UTC) - different formats available.
- Memory Management
  - It's being handled automatically in golang.
  - It has two functions new() and make()
  - Both functions accepts data types such that pointer, array, slice etc
  - new() works with zeroed storage which means it does not accept any value initially. In simple words, we cannot store anything initially in new() function.
  - new() cannot be initialized initially
  - make() accept storage
  - make() can be initiallized
- GC - Garbage collection
  - ...
- Pointers
  - Pointer is a reference to the direct memory location, something like this 0xc0000b2008 etc
  - When we create any variable or constant, it gets stored in a location in memory and takes some space into memory.
  - When we call this variable/constant then sometimes it's reference passed on instead of actual value.
  - Why we need pointers:
    - Sometimes we have to be guranteed that actual value should be passed on and not the reference. It may comes up with some kind of irregularities in code.
    - So to avoid such kind of irregularities, we use __Pointers__.
  - __In Simple words__
    - A Pointer is nothing, it's just a direct reference to a memory address and since we are directly passing an address it makes 100% gurantee that actual value is being passed on.
  - Syntax:
    - var ptr *int
      - var -> keyword
      - ptr -> var name
      - *int -> this pointer is of type integer which means it will store integer value in this pointer.
    - myNumber := 23
    - var ptr := &myNumber
      - & (amp sign) -> it means we are not just initializing a var but also referencing an initialized var.
      - So whenever there is a talk about "reference" then we will use "& (sign)".
      - myNumber := 26 -> Initializing var and assigned value to it.
      - var ptr = &myNumber -> Re-initializing var with already initialized variable. But this time referencing with & sign
      - fmt.Println("Value of ptr is", ptr) -> It will print the direct location of memory (or memory address) of variable
      - fmt.Println("Value of ptr is", *ptr) -> The value inside this //*ptr (pointer) will be 26.
        - When I put *ptr, it means I want to see what's inside that pointer?
        - How I was able to fill that?
        - I was able to fill that by adding a reference to &myNumber.
        - *ptr means it's not memory address. It's an actual value inside of it which is 26 in our case.
  - Pointer gives us the gurantee that the operation will be performed on Actual value.
- Array
  - Syntax
    - var fruitList [4]string
      - var -> keyword
      - fruitList -> var name
      - [4] -> Length of array, which means elements in Array.
      - string -> data type
      - var fruitList [4]string -> here, we just declared an array but not initialized.
      - fruitList[0] = "Apple" -> here, we initialized the array with value.
      - fruitList[1] = "Mango"
      - fruitList[3] = "Orange"
      - In above case, it will print 3 values in sequence (FruitList is:  [Apple Peach  Mango]) notice the space between Peach and Mango. This is because of index 2 that we left to initialize and its keep printing the value of it.
      - We can only print those elements that we defined during variable declaration.
    - var vegeList = [3]string{"Potato","Mushrom","Tomato"}
    - fmt.Println("Elements in vegeList", len(vegeList))
    - fmt.Println(len(vegeList[0]))
- Slices in golang
  - Main difference in between array and slices is if we are defining a value in sqaure braces then it means a simple array for example:
    - var list = [4]string
  - If there is no value inside the braces then this is "slice". for example
    - var list = []string
      - If we are using this syntax then we must initialized it as well for example
        - var list = []string{"Apple", "Mango", "Banana"}
  - Array was defined very precisely and we cannot assign value more than we defined in array.
  - In Slices, we can add many values as we like and it keeps expanding memory for us.
  - Syntax:
    - var sliceList = []string{"Apple", "Mango", "Banana"}
    - Notice the difference. We didn't add elements in square braces above.
  - Slice will return following type:
    - []string
- How to append any element in existing slice:
  - In slices, we have append function which requires some arguments. for example:
    - sliceList = append(sliceList, "Peach","Orange")
  - Define slice using make()
  - Syntax:
    - highScores := make([]int, 4)
- Slicing in slice (array)
  - colon (:) between two elements slice up the slice. In simple words, if you want to make a separate part of slice then use colon (:)
  - Range is always non-inclusive in golang which means it does not include in result.
  - Syntax:
    - sliceList = append(sliceList[1:])
      - In result, it will start from the first elemnent which is Apple. But Apple is at the zeroed index of slice.
    - sliceList = append(sliceList[1:3])
      - Array elements -> [Apple Mango Banana Peach Orange]
      - It will start from Mango because 0 is not counted here...
      - Second element is Banana
      - Third element is Peach but it will not be printed because the last range is always non-inclusive, that's why Peach will not be printed.
- Remove item from slice based on index
  - First we need to declare index number that we want to remove
  - then we need to write :(colon) syntax that we used before to add items in slice
  - Syntax
    - [javascript Java C# golang swift] -> slice items
    - var index int = 2
      - We want the value on index number 2 to be deleted
    - cources = append(cources[:index], cource[index+1:]...)
      - :index -> start from default value which is on 0th position and go to index(th) position which is C#. This is not inclusive.
      - It will start from javascript, take java and leave C#
      - cource[index+1:] -> start from index+1 (2+1=3) which means golang...and go till end
      - ... : not sure about these 3 dots at the moment.
  - In simple words, to remove an item from array (or slice) we can delete that item by skipping it.
- Maps in golang
  - Maps also known as hash table or key value pairs in some languages.
  - We can use make() to create whether it is slice or map. for example:
    - languages := make()
  - Syntax:
    - abbreviations := make(map[string]string)
    - make() -> is a function that handles memory management.
      - it can accept storage which means it wont give errors with non-zeroed storage
      - map[string]string -> map is data type which we must define when working with maps in golang.
      - [string]string -> first string represents the key
      - string -> this second string represents the value
    - initialize variable:
    - abbreviations["JS"] = "JavaScript"
    - it will print "map[JS:JavaScript OS:OperatingSystem PS:PowerShell]"
- Delete key value pair from map in golang
  - Syntax:
    - delete(abbreviations, "JS") -> it requires only key to remove the pair from map.
- Structs in golang
  - Structs is an alternative of class because golang doesn't have classes.
  - No inheritance in golang.
  - No parent child concept do exist in golang.
  - How do we define struct in golang?
    - First, we need to define the structure and then can utilize it anywhere in different ways.
    - Syntax:
      - type User struct {}
      - type -> first we use a keyword "type"
      - User -> notice the first letter that is capital which means publicaly available. It also means that since it is an alternative of class so similarly it can be exported.
      - struct -> here we are saying that I want to define the structure.
      - {} -> curly braces to define the structure.
- Note about structs
  - Make sure the following:
    - There is no inheritance in golang
    - The first letter of element in structure should be upper-case (with capital letters) so it can be exported and accessed by anyone.
- If/Else in golang
  - We can write if/else logic on the go. 
  - for example:
    - initialize and assign value to variable
    - check if/else. for example
    - if num := 3 , num > 3
- Switch Case
- Loops in golang
  - golang has only one type of loop which is for-loop
  - basic syntax to understand the loops (basic for loop)
    - for initialization; condition; post{
       // statements....}
      - The initialization statement is optional and executes before for loop starts. The initialization statement is always in a simple statement like variable declarations, increment or assignment statements, or function calls.
      - The condition statement holds a boolean expression, which is evaluated at the starting of each iteration of the loop. If the value of the conditional statement is true, then the loop executes.
      - The post statement is executed after the body of the for-loop. After the post statement, the condition statement evaluates again if the value of the conditional statement is false, then the loop ends.
  - It's good to define a data structure which we want to loop through on.
  - Best option is to define slice as below:
    - days := []string{"Saturday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday"}
    - for d := 0; d < len(days); d++{
    - fmt.Println(days[d])}
      - d -> is similar to 'i' we have been working when defining loop in different languages.
        - so here, d is equal to 0
      - d < len(days) -> run the loop till the value in 'd' is less than the values defined in slice (days)
        - so, here we have all elements in len(days).
      - d := 0; d < len(days)
        - loop will start from 0
        - 0 < 7 (0 is less then 7)
      - d++
        - d = 0+1
        - print the value from d(th) position which will be Saturday in first run.
        - so, I want to print out whats the value of days at the present d, means 0th position, 1st position, 2nd position etc
  - for loop in writing style of while loop
    - num := 0
    - for i < 5 {
      - fmt.Println(i)
      - num++
    - }
  - break in loops
    - is actually imediatly exits the loop.
    - it doesn't look for what after the break is in curely braces.
    - it also exits the loop even the condition is staisfying.
    - in simple words: exits and goes to the end.
  - continue in loops
    - it imediatly jumps to beginning of the loop and skip rest of the statements.
    - in simple words: jumps back right to the beginning.
- functions in golang
  - Basic syntax:
    - func main(){}
    - main is an entry point in golang
    - as soon as we create main function we don't even need to call it and can execute the file (go run main.go)
    - because golang knows that main is an entry point.
  - Function inside the function is not allowed.
    - It will throw an error saying "expression is expected and not function"
    - but there is a when it is allowed:
      - when we assign func to a variable. See a complete example in [main.go](00practice/main.go)
      - func main(){
      - test := func(){
        - fmt.Println("hello world")
      - }
      - test()
      - }
  - ... (three triple dots) are variadic functions and they can expect any values.
  - When we call any function then it direclty jumps to the function declaration, performs operation and return back to the line where it jumped from.
  - We write function to resue it and avoid copy pasting code etc.
  - We can have multiple parameters in function call even with different data types, for example:
    - func add(num1 int, num2 int){}
    - func add (num1 int, name string){}
  - function declaration
    - func add(num1 int, num2 int){
    - fmt.Println(num1 + num2)}
      - We need to pass stuff as parameter if we want any operation to be performed using this function.
      - We also need to define it's type, i.e. int, string, float64 etc
      - fmt.Println(num1 + num2) -> in this function, we want to add two numbers
  - function call
    - add(5,5)
      - in Function call, we just need to pass value as comma separated. Do not put any operand in function call for example +, -, * (multiply) etc
  - variadic function
    - sometimes we dont know how many values are going to come in to function call, hence we cannot define it as an argument.
    - for example: in this case, we know two values are there in function declaration. Syntax:
      - func add(num1 int, num2 int) int {return num1 + num2}
      - add(5,5) 
    - In order to support this case, we can use variadic function, for example:
      - refer to folder 15functions for example.
    - This is similar to append method in slices.
  - return keyword (returning result)
    - Sometimes instead of priting the result we want to hold it and use later on or manipulate them.
    - If we are not willing to get things done directly in function declaration then we can simply pass the result to someone else to perform certain operation on behalf of us.
    - we need to use return keyword in function declaration.
    - we also need to add type of value that we want to return
      - for example if we want to return 'int' then we need to define 'int' after parantheses (and before curly braces)
        - Syntax of return
          - func add(num1 int, num2 int) int {
            - return num1 + num2
          - }
          - ans := add(5,5)
          - fmt.Println(ans)
    - if we are returning two data types then we need to enclosed both types in parantheses as below:
      - func data(num1 int, name string) (int, string){}
  - We can omit data type and define only once if parameters are of the same data type. for example:
    - func add(num1, num2 int){}
  - label our return value
    - We can lable return values in golang
    - Syntax:
      - func add(num1, num2 int) (lbl1 int){
      - lbl1 = num1 + num2
      - return
      - }
      - In this case, I dont need to write something like this: return num1 + num2 because we've labled our return variable.
- Difference between Method and function
  - function -> when we do regular things and waraped up that is called function.
  - Method -> Since golang does not have classes so when these functions go into the classes (or struct in golang) then it is called method.
- Methods in golang
  - Because of not having classes in golang, we need to bring our functions into structs so we can call them methods.
  - to create a method we should have sturct that we can pass on to method as object. for example:
  - func (u User) method_name(){}
    - u -> representing to an object (or struct) which is User
    - User -> is a struc we've defined in 11structs file.
  - Basic syntax
    - see line 19 in [16method.go file](/16methods/main.go)
  - Important notes
    - Whenever we pass on these objects (or structs) it actually passes on a copy, here comes the concept of pointers in golang
    - So to pass the original object, we should be passing up the reference of it (or a pointer to that).
- Defer in golang
  - defer means "to postpone" or in Urdu "Muakhar karna"
  - code executes line by line in golang
  - defer is a keyword in golang.
  - defer means, it delays the execution of code (line) that has defer with it. for example:
    - func main(){
      - defer fmt.Println("World")
      - fmt.Println("Hello")
      - }
      - This "world will get jump this line 389 to very end of the block before curly braces.
      - So, it will print, Hello, World.
  - In reverse order, it works like "LIFO" (last in first out)
  - More examples and notes added in [17defer.go file](/17defer/main.go)
  - As soon as we see 'defer' then execution of it will get little delay.
- Working with files in golang
  - Using built-in packages, we can only read txt file in golang
  - to read/write csv file, we need external package
  - We need following items in order to perform read/write operations in golang
    - content
    - create file
    - read file
  - Packages we need to use for "working with file in golang"
    - os
      - os.Create 
        - -> to create the file
        - -> it requires one argument, file name(file path) which has to create.
    - io
      - io.WriteString 
        - -> to write string in file
        - -> it requires two arguments, file and content
    - ioutil
      - ioutil.ReadFile 
      - -> to read the file
      - It requires one argument which is file data
- Handling web request in golang
  - This is about, How we can make a request to URL
  - Whenever we send a request to any web server (or website), it returns with a response object.
    - So, to handle this web request and response we use net/http package in golang.
    - http package has so many functions, types and methods etc to work with it.
    - We will start with GET
    - If we want to handle response object then we need to use type "Response" within http package.
  - Close (this is a type in http package)
    - Whenever we make a new request to any website, it is our responsibility to close the connection because neither ReadResponse nor Response.Write does this.
  - At this stage,
    - First of all, we need to define a url in global space
    - In most cases, there is a separate function for this request handling so we can use it anywhere but at this stage we're gonna write the code in 'main' function.
  - Type of response
    - Type of response is *http.Response which is a pointer. Having the type of response is pointer means, we will get an original value and not the copy of it.
  - ioutil
    - Previously in file handling, we used ioutil with ReadFile (like this ioutil.ReadFile) but in response handling, we will use ioutil.ReadAll
    - Majority of the reading is done by ioutil package (it's majority and not all)
    - After reading response, we also need to convert it to string
- URL handling in golang
  - We do have "url" library in golang to work with url handling
  - Parsing means we want to extract some information from the url (in context meaning)
    - When we do Parsing on a URL then there comes up so many details from that url.
    - Syntax:
      - url.Parse() -> pass url as an argument
  - Constructing URL
    - We can also construct url if we already have values for example, protocol, host, port, path etc
    - In this case, we must need to pass the reference of url. This is very important. For example
      - partsOfUrl := &url.URL{} -> this is the syntax of constructing url.
  - Three important packages:
    - url.Parse() this (.Parse()) function parses the url. for example url.Parse(url)
    - parsedUrl.Query() this (.Query()) function helps us to extract the query parameters in a format of key value pair.
    - partsOfUrl.String() -> this (.String()) will construct the url with the values provided in &url.URL{}
    - See this [main.go](/20urlhandling/main.go) for code.
- Web Request with Get Method
  - string is a data type
  - strings is a package in golang
  - ioutil.ReadAll(response.Body)
    - We use ioutil to read the body of response. This is of type "byte" hence we do convert it into string.
- Web Request with POST Method
  - We do mostly sends the data either in json format or in url-encoded forms.
  - http.Post
    - This method requires some parameters
      - url -> whatever the url it is there
      - data type -> string or json...
        - if it's json then -> make sure it should be something like this "application/json"
      - content/data -> request body
  - Create fake json payload
    - Syntax:
      - requestBody := strings.NewReader(`
      - {
        - "name":"Zeeshan"
        - "age": 32
        - "website":"https://acloudtechie.com"
      - }`)
- Web Request with Postform
  - In this request, we are gonna send form data with our request
  - Method to be used for this:
    - url.Values
      - .Values -> is the method to be used to work with post form request.
    - Syntax:
      - url.Values{} -> initially keep the defination empty so later values can be assigned to it.
      - data := url.Values{} -> first assign the value to variable.
      - data.Add() -> use Add method to add fake values.
- Create Json Data in golang
  - encoding of json:
    - it means, we have the data in any format, either it is slices, string or int. We need to convert it into json that is called encoding in this section.
  - json.Marshal() 
    - .Marshal() is used to encode the data in json format.
    - it requires one parameter which is struct
  - json.MarshallIndent() 
    - It will indent the content in proper format and not in single line.
    - it requires three parameters:
      - struct (interface)
      - prefix (it could be empty string) "" -> this will add in all lines of output so if there is something else then it will print similar to this.
      - "\t" -> this is for tab, similar to \n for new line
  - To encode data in JSON format:
    - First we need to define data structure
    - Second we need to create the data that has to be package as JSON
    - Third package the data in JSON format
  - Creating alias of Keys in data structure (struct)
    - Syntax:
      - type Profile struct {}
        - This can accepts parameters for example
          - Name string -> string is one parameter
        - Now, If we want to create an alias of this name so it prints alias and not the actual key then we need to add another parameter something like this:
          - Name string `json:"fullname"` (followed with back tick and json keyword)
          - head over to [this](/22encodingjson/main.go) file from line number 16 to 23
    - Important note:
      - If your API contains some sensitive information and you want to omit this for people consuming your APIs then we can do something like this in our struct:
        - Password string `json:"-"`
          - This will omit Password key and it's value to be printed in output.
      - omitempty
        - what this means is if any value is empty(or nil) in against a key in struct then it will not be printed out. for example:
          - tags []string
            - If someone didn't provide the value and only provided 'nil' then it will print "null" in output
          - tags []string `json:"tags,omitempty"`
            - Above will not print any value which were not provided as struct's value.
            - See [here](/22encodingjson/main.go) for complete code.
- Create Json Data in golang
  - Decoding JSON data
    - It means, how we can consume the JSON data.
      - In many cases, JSON data will come to us as an API resource or from any other backend.
      - We should be able to consume that JSON data.
      - But, before consuming it, we need to decode it
  - The data that is coming from web will be in slice of byte format. something like this:
    - []byte()
      - So, in order to create JSON data we need to use this data inside slice of byte .
    - First thing: we should have JSON data. (at this stage)
      - So, first of all, create a var of type struct
        - In our case it is Profile, something like this
          - var jsonData Profile
      - Why we are using previously created struct again?
        - May be there is usecase that we would not want to create the structure again and use the same to add json data in it.
  - Second of all we need to check either the json data is valid or not. Use this function:
    - json.Valid(data)
  - Third, if/else to check if json is valid or not:
    - if valid, then json.Unmarshal(), it accepts two parameters: jsonData, interface
      - jsonData -> the data available to use in json format
      - interface -> another name of struct, so we need to put struct here
      - Make sure to pass reference of structure and not the copy
        - json.UnMarshal(jsonDataFromFile, &userData)
        - See [DecodeJSON()](/challengeExercises/profile_v1.go) function for example
  - Print decoded json data:
    - fmt.Printf("%#v\n", struct)
      - %#v -> this is special format to print struct's value that is coming from structure
  - Important
    - Whenver we are creating map to get the JSON data, we always know that first value (or key) will be string but for second value, we don't know because either it could be an array, integer or string etc.
- Go modules
  - Workspaces have almost gone from golang, if there is any legacy application then it's a good time to change it with Module system in golang. go mod is here to do that.
  - go mod is a tooling
  - go gives us lot of stuff which we can use for tooling.
  - Actually these are the tools which we can use for variety of reasons. for example:
    - go build -> we can make builds using this tool.
    - go run -> it runs at low cost as compare to "go build"
    - go mod 
    - go env -> it is another set of tooling
    - go tidy -> When we've added any third party library, it will be showing as "Indirect". When we've used that library into our code and if it still shows "Indirect" then we execute this command.
      - It also removes all the package that we are not using.
      - It tidies up all the libraries that we are depending on that.
      - It also bring us all the packages that we've removed from our code.
    - go mod verify
    - go list all -> it will show (or list down) all the packages that are installed in local system.
    - go list -m all -> it will only show the package that we are using in our code.
  - Important:
    - make sure that every operation with "go mod" is very expensives so remember it when working with CICD etc
    - go mod graph -> it will print in a way which package is dependent on which pagkage
    - go mod edit -> this it to edit the go.mod file and not manually.
      - go mod edit -go 1.16 -> to change the go version
      - go mod edit -module 1.16
    - go mod vendor
    - go run -mod=vendor main.go
  - Where packages goes in filesystem?
    - It does not go into the workspace (or working directory of code). It goes to another directory which we can see by executing go env command and see GOPATH variable.
  - gorilla/mux package
    - to serve the url and do operations accordingly.
    - w -> it represents to ResponseWriter -> This is a function of http package. Syntax: http.ResponseWriter
    - r -> it represents to Request -> This is also a function of http package. Syntax: *http.Request
      - Make sure that, this 'r' http.Request is a pointer.
    - How and Why use those w and r parameters?
      - When somebody sending us a request -> for example, if we want to use parameters, urls etc that all is inside the 'r' (*http.Request)
      - We need to send some response to that request that is inside the 'w' (http.ResponseWriter)
      - So, to send response back to a request, we need to use 'w' which means "Write a response for me" by using Write function. Syntax:
        - w.Write()
          - this Write function accepts "slice of byte" because the data is coming from the web.
          - write whatever the reponse you want to return back.
            - w.Write([]byte("<h1>Hello World!</h1>"))
    - Now, we need to copy paste below code from gorilla/mux library:
      - r := mux.NewRouter()
      - r.HandleFunc("/", HomeHandler) -> it accepts two parameters: request and response
        - "/" is the request
        - HomeHandler is the response so here we will add serveHome function but instead of doing like this we will add the reference of it.
        - .Methods("GET") -> complete syntax: r.HandleFunc("/", HomeHandler).Methods("GET")
    - Now, we need a server to send or receive a response. Creating server in golang is super easy (as per Hitesh)
    - We can use a function from http package:
      - http.ListenAndServe() -> it requires port and router (request either it is for "/" or "/product" etc)
      - http.ListenAndServer(":8000", r)
    - Now, during this operation we can face any errors or exception or any issues. So to cater this, we need to use:
      - log.Fatal(<server creation code>)
        - log.Fatal(http.ListenAndServe(":8000", r))
- Build API in golang
  - gorilla/mux
    - package in golang to create/build API
  - Follow the steps:
    - Create model for course and author
      - model means, how our course is looks like
      - We can also call it as database (or model as described above)
    - Create helper method to check if id and name is not empty.
    - Create controllers
      - Contollers always goes into separate files but at this stage, we are going to define in same file.
      - controller here means, a router which will serve request and response (or do whatever we will say to) for example if the request is for "/" then response back with "Welcome to acloudtechie.com"
      - ....in progress