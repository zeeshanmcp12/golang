# Notes

Notes are written for my own understanding so these may be inappropriate for others to understand. But I tried to write in a way so any begineer can understand.

## 01Into

- Create directory named 01Into
- Open this in "Integrated terminal"
- Execute "go mod init hello" -> it will initialize a module named "hello" as well as create go.mod file.
- Create main.go file.
- Write "package main" (on top of file)
- to print the hello world:
  - initialize function with:
        func main(){ fmt.Println("Hello World")}
  - fmt is a package in golang
  - Println is a method
  - adding fmt in function will import "fmt" package (in golang, we don't need to import packages manually)
- go help -> for go documentation and find out the command etc.
  - go run help -> it will specifically come up with the help related to "run" command
  - go env GOPATH -> to know more about env variable for go.
  - environment variable path for windows: C:\Users\%USERPROFILE%\go
- lexer
  - is who knows the grammer of language like where to put semicolon and where it should not etc.
  - this is something who can add/remove semicolon at the end of the line. for example:
    - we can put semicolon at the end of line 6 (before curely braces) in main.go file but lexer will remove that semicolon because we've installed intellisence from go language.
- types
  - case insensitive - almost everything in go language
  - Everything is type in golang.
  - first initial letter of type gives idea about whether the type is public or private. for example, Println function.
  - const LoginName string -> this capital 'L' in variable (LoginName) declares that it is public and available across the files and program.
  - This Println function was written in a way that it can be used publically. Some other functions that help to this Println are not exposed publically.
  - Similar to other languages, go also has types for example, string, bool, integr, float, complex
  - some advance types: array, slices, maps, structs, pointers
- User Input
  - to take an input from user (or from keyboard), in golang we need to have some packages which are bufio and os.
  - buffer i/o will help to buffer the i/o and os package will help to get the input from user (or from keyboard)
  - syntax:
    - reader := bufio.NewReader(os.Stdin)
      - reader -> variable
      - := -> operator for assignment and declaration
      - bufio -> go package (buffer) which can read from input/output so we can read from keyboard, from printers and other resources.
      - NewReader -> method of bufio package -> public because of first letter is capital.
      - But, from where we should be reading up? to answer the question, we added os.Stdin.
      - os -> go package (this is another library to interect with OS.)
      - Stdin -> method of os package.
    - As soon as we save the file with above syntax, it will import both libraries(packages) (bufio and os)
    - till above syntax, a process is going on to read the input (is syntax tak koi na koi process read kar raha hai.)
    - whatever this (reader var) reads, we want to store it into a variable (called input (in line 51)) but here comes "comma ok || err ok" syntax into play.
  - comma ok syntax || err err
  - syntax
    - input, _ := reader.ReadString('\n')
      - input -> whatever an input will be given
      - _ -> (underscore) means, if any mistake/error occurs during input so this is something try catch.
      - we can write "err" instead of "_(underscore)" but its fine.
      - reader -> is a variable we declared above
      - .ReadString -> is a method which will wait (or read) for string we gonna input.
      - ('\n') -> represents new line so reader.ReadString will read for string till we press "Enter".
  - Why we put input, _?
    - It is expected that, when reading something (from Stdin (standard input) for example) there might be chances of something might go wrong, and for that wrong thing there might be an error comes in. In that case, we can go and store just like this "input, err" (this might give an error because we may not be using it but this is how golang syntax works)
    - So, this is something like "comma ok || err err" syntax.
    - If everything goes right, it will give me input.
    - If any wrong happens then it will through an error.
- Conversion
  - to convert the string into integer, we have strconv library in golang (as I know till the time of writing these notes)
  - Syntax
    - numRating, err := strconv.ParseFloat(strings.TrimSpace(input), 64)
      - numRating -> new variable so we can see conversion in action.
      - err -> the variable we discussed above in "comma ok || err err" syntax
      - strconv.ParseFloat -> ParseFloat is a property of strconv function which takes two arguments, string and bit size (which is 64 in the case of Float)
      - strings.TrimSpace()
        - strings is also a powerfull package in golang which has so many features for example ToLower, Map, TrimSpace etc
        - TrimSpace() is a function which will trim spaces.
          - Remember we used '\n' in reader.ReadString('\n') to read the input till we press enter.
          - so, when we type any number and press enter then this is not just a number but a trailing(\ character) as well which is being used here. so to remove the trailing or any space or any first character, we used this TrimSpace() function.
          - So, TrimSpace() will trim this (\n) character and convert it into Float.
        - strings.TrimSpace(input) -> this is an argument (s string) of ParseFloat function.
      - 64 -> is a bit size and 2nd argument of ParseFloat.
- Random Numbers
  - there are two packages
    - math/rand
    - crypto/rand
  - math/rand
    - this package can generate random numbers but not guranteed as not governed by good algorithm for random numbers.
    - sometimes it returns the same number unless you use Seed with rand package i.e. rand.Seed()
    - It will keep generating same number unless you change number in Seed.
    - The range we define in rand function is always exclusive. for example if we define range as '5' then the number will be generated from 0 to 4 and not 5.
    - Syntax:
      - fmt.Println(rand.Intn(5))
      - above syntax will always return the same number between 1 and 4.
        - Why?
          - because in golang it considers that nothing is random in Computer hence everything is driven by algorithm.
          - Some programs, some methods and some algorithm are written by somebody.
          - Hence this algorithm is written by Seed (rand.Seed())
          - We have to change the number in Seed so it will give us random number. But this is not something we want to achieve.
        - How we can achive the random number using math/rand?
          - The only thing which keep on changing is time (no matter what you do).
          - Now, it is much guranteed that the Seed (rand.Seed()) is being initialized by a truely random number (every single time) and we are expected to get the random number.
        - Syntax
          - rand.Seed(time.Now().UnixNano())
          - fmt.Println(rand.Intn(5))
    - crypto/rand
      - this packages gives us surety about randomness of number because it goverened by a cryptograpghy algorithm.
      - We can use this package to generate secure information for example token etc.
        - Syntax
          - randomNum, _ := rand.Int(rand.Reader(), big.NewInt(5))
          - fmt.Println(randomNum)
- time
  - we need to use time package to use and format time in golang
  - time.Now()
  - Syntax
    - presentTime := time.Now()
    - fmt.Println(presentTime)
  - Formatting time:
    - to format the time, we need to use 'Format' method.
      - fmt.Println(presentTime.Format("2006-01-02 15:04:05 Monday"))
      - 2006-01-02 15:04:05 Monday ->
        - 2006 -> will always represent to current year (in output)
        - 01 -> will represent to Month
        - 02 -> will represent to Date
        - Monday -> will represent to Current Day
        - Output -> 2022-01-13 Thursday
        - 15 -> current Hour
        - 04 -> minute
        - 05 -> second
    - How to create a Date with formatting:
      - Syntax
        - createdDate := time.Date(2021, time.December, 03, 07, 00, 00, 00, time.Local)
        - time.Date() -> function to be used for creating Date in golang
        - year -> is an integer
        - month -> comes from time package and it has to be used only with time. for example time.December
        - day -> int. for example 03
        - hour -> int. 07
        - minute -> int. 00
        - second -> int. 00
        - nano second -> int 00
        - location -> time.Local (time.UTC) - different formats available.
- Memory Management
  - It handle automatically in golang.
  - It has two functions new() and make()
  - Both functions accepts data types such that pointer, array, slice etc
  - new() works with zeroed storage which means it does not accept any value initially. In simple word, we cannot store anything initially in new() function.
  - new() cannot be initialized initially
  - make() accept storage
  - make() can be initiallized
- GC - Garbage collection
  - ...
- Pointers
  - Pointer is a reference to the direct memory location, something like this 0xc0000b2008 etc
  - When we create any variable or constant, it gets stored in a location in memory and takes some space into memory.
  - When we call this variable/constant then sometimes it's reference passed on instead of actual value.
  - Why we need pointers:
    - Sometimes we have to be guranteed that actual value should be passed on and not the reference. It may comes up with some kind of irregularities in code.
    - So to avoid such kind of irregularities, we use __Pointers__.
  - __In Simple words__
    - A Pointer is nothing, it's just a direct reference to a memory address and since we are directly passing an address it makes 100% gurantee that actual value is being passed on.
  - Syntax:
    - var ptr *int
      - var -> keyword
      - ptr -> var name
      - *int -> this integer is of type integer which means it will store integer value in this pointer.
    - myNumber := 23
    - var ptr := &myNumber
      - & (amp sign) -> it means we are not just initializing a var but also referencing an initialized var.
      - So whenever there is a talk about "reference" then we will use "& (sign)".
      - myNumber := 26 -> Initializing var and assigned value to it.
      - var ptr = &myNumber -> Re-initializing var with already initialized variable. But this time referencing with & sign
      - fmt.Println("Value of ptr is", ptr) -> It will print the direct location of memory (or memory address) of variable
      - fmt.Println("Value of ptr is", *ptr) -> The value inside this //*ptr (pointer) will be 26.
        - When I put *ptr, it means I want to see what's inside that pointer?
        - How I was able to fill that?
        - I was able to fill that by adding a reference to &myNumber.
        - *ptr means it's not memory address. It's an actual value inside of it which is 26 in our case.
  - Pointer gives us the gurantee that the operation will be performed on Actual value.
- Array
  - Syntax
    - var fruitList [4]string
      - var -> keyword
      - fruitList -> var name
      - [4] -> Length of array, such that elements to be in Array.
      - string -> data type
      - var fruitList [4]string -> here, we just declared an array but not initialized.
      - fruitList[0] = "Apple" -> here, we initialized the array with value.
      - fruitList[1] = "Mango"
      - fruitList[3] = "Orange"
      - In above case, it will print 3 values in sequence (FruitList is:  [Apple Peach  Mango]) notice the space between Peach and Mango. This is because of index 2 that we left to initialize and its keep printing the value of it.
      - We can only print those elements that we defined during variable declaration.
    - var vegeList = [3]string{"Potato","Mushrom","Tomato"}
    - fmt.Println("Elements in vegeList", len(vegeList))
    - fmt.Println(len(vegeList[0]))
- Slices in golang
  - Main difference in between array and slices is if we are defining a value in sqaure braces then it means a simple array for example:
    - var list = [4]string
  - If we dont define values there then it means this is "slices". for example
    - var list = []string
      - If we are using this syntax then we must initialized it as well for example
        - var list = []string{"Apple", "Mango", "Banana"}
  - Array was defined very precisely and we cannot assign value more than we defined in array.
  - In Slices, we can add many values as we like and it keeps expand memory for us.
  - Syntax:
    - var sliceList = []string{"Apple", "Mango", "Banana"}
    - Notice the difference. We didn't add elements in square braces above.
  - Slice will return following type:
    - []string
- How to append any element in existing array:
  - In slices, we have append function which requires some arguments. for example:
    - sliceList = append(sliceList, "Peach","Orange")
- Slicing in slice (array)
  - colon (:) between two elements slice up the slice. In simple words, if you want to make a separate part of slice then use colon (:)
  - Range is always non-inclusive in golang which means it does not include in result.
  - Syntax:
    - sliceList = append(sliceList[1:])
      - In result, it will start from the first elemnent which is Apple. But Apple is at the zeroed index of array.
    - sliceList = append(sliceList[1:3])
      - Array elements -> [Apple Mango Banana Peach Orange]
      - It will start from Mango because 0 is not counted here...
      - Second element is Banana
      - Third element is Peach but it will not be printed because the last range is always non-inclusive, that's why Peach will not be printed.
- Remove item from slice based on index
  - First we need to declare index number that we want to remove
  - then we need to write :(colon) syntax that we used before to add items in slice
  - Syntax
    - [javascript Java C# golang swift] -> slice items
    - var index int = 2
      - We want the value on index number 2 to be deleted
    - cources = append(cources[:index], cource[index+1:]...)
      - :index -> start from default value which is on 0th position and go to index(th) position which is C#. This is not inclusive.
      - It will start from javascript, take java and leave C#
      - cource[index+1:] -> start from index+1 (2+1=3) which means golang...and go till end
      - ... : not sure about these 3 dots at the moment.
  - In simple words, to remove an item from array (or slice) we can delete that item by skipping it.
- Maps in golang
  - Maps also known as hash table or key value pairs in some languages.
  - We can use make() to create whether it is slice or map. for example:
    - languages := make()