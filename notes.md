# Notes

Notes are written for my own understanding and not for others

## 01Into

- Create directory named 01Into
- Open this in "Integrated terminal"
- Execute "go mod init hello" -> it will initialize a module named "hello" as well as create go.mod file.
- Create main.go file.
- Write "package main" (on top of file)
- to print the hello world:
  - initialize function with:
        func main(){ fmt.Println("Hello World")}
  - fmt is a package in golang
  - Println is a method
  - adding fmt in function will import "fmt" package (in golang, we don't need to import packages manually)
- go help -> for go documentation and find out the command etc.
  - go run help -> it will specifically come up with the help related to "run" command
  - go env GOPATH -> to know more about env variable for go.
  - environment variable path for windows: C:\Users\%USERPROFILE%\go
- lexer
  - is who knows the grammer of language like where to put semicolon and where it should not etc.
  - this is something who can add/remove semicolon at the end of the line. for example:
    - we can put semicolon at the end of line 6 (before curely braces) in main.go file but lexer will remove that semicolon because we've installed intellisence from go language.
- types
  - case insensitive - almost everything in go language
  - Everything is type in golang.
  - first initial letter of type gives idea about whether the type is public or private. for example, Println function.
  - const LoginName string -> this capital 'L' in variable (LoginName) declares that it is public and available across the files and program.
  - This Println function was written in a way that it can be used publically. Some other functions that help to this Println are not exposed publically.
  - Similar to other languages, go also has types for example, string, bool, integr, float, complex
  - some advance types: array, slices, maps, structs, pointers
- User Input
  - to take an input from user (or from keyboard), in golang we need to have some packages which are bufio and os.
  - buffer i/o will help to buffer the i/o and os package will help to get the input from user (or from keyboard)
  - syntax:
    - reader := bufio.NewReader(os.Stdin)
      - reader -> variable
      - := -> operator for assignment and declaration
      - bufio -> go package (buffer) which can read from input/output so we can read from keyboard, from printers and other resources.
      - NewReader -> method of bufio package -> public because of first letter is capital.
      - But, from where we should be reading up? to answer the question, we added os.Stdin.
      - os -> go package (this is another library to interect with OS.)
      - Stdin -> method of os package.
    - As soon as we save the file with above syntax, it will import both libraries(packages) (bufio and os)
    - till above syntax, a process is going on to read the input (is syntax tak koi na koi process read kar raha hai.)
    - whatever this (reader var) reads, we want to store it into a variable (called input (in line 51)) but here comes "comma ok || err ok" syntax into play.
  - comma ok syntax || err err
  - syntax
    - input, _ := reader.ReadString('\n')
      - input -> whatever an input will be given
      - _ -> (underscore) means, if any mistake/error occurs during input so this is something try catch.
      - we can write "err" instead of "_(underscore)" but its fine.
      - reader -> is a variable we declared above
      - .ReadString -> is a method which will wait (or read) for string we gonna input.
      - ('\n') -> represents new line so reader.ReadString will read for string till we press "Enter".
  - Why we put input, _?
    - It is expected that, when reading something (from Stdin (standard input) for example) there might be chances of something might go wrong, and for that wrong thing there might be an error comes in. In that case, we can go and store just like this "input, err" (this might give an error because we may not be using it but this is how golang syntax works)
    - So, this is something like "comma ok || err err" syntax.
    - If everything goes right, it will give me input.
    - If any wrong happens then it will through an error.
- Conversion
  - to convert the string into integer, we have strconv library in golang (as I know till the time of writing these notes)
  - Syntax
    - numRating, err := strconv.ParseFloat(strings.TrimSpace(input), 64)
      - numRating -> new variable so we can see conversion in action.
      - err -> the variable we discussed above in "comma ok || err err" syntax
      - strconv.ParseFloat -> ParseFloat is a property of strconv function which takes two arguments, string and bit size (which is 64 in the case of Float)
      - strings.TrimSpace()
        - strings is also a powerfull package in golang which has so many features for example ToLower, Map, TrimSpace etc
        - TrimSpace() is a function which will trim spaces.
          - Remember we used '\n' in reader.ReadString('\n') to read the input till we press enter.
          - so, when we type any number and press enter then this is not just a number but a trailing(\ character) as well which is being used here. so to remove the trailing or any space or any first character, we used this TrimSpace() function.
          - So, TrimSpace() will trim this (\n) character and convert it into Float.
        - strings.TrimSpace(input) -> this is an argument (s string) of ParseFloat function.
      - 64 -> is a bit size and 2nd argument of ParseFloat.
- Random Numbers
  - there are two packages
    - math/rand
    - crypto/rand
  - math/rand
    - this package can generate random numbers but not guranteed as not governed by good algorithm for random numbers.
    - sometimes it returns the same number unless you use Seed with rand package i.e. rand.Seed()
    - It will keep generating same number unless you change number in Seed.
    - The range we define in rand function is always exclusive. for example if we define range as '5' then the number will be generated from 0 to 4 and not 5.
    - Syntax:
      - fmt.Println(rand.Intn(5))
      - above syntax will always return the same number between 1 and 4.
        - Why?
          - because in golang it considers that nothing is random in Computer hence everything is driven by algorithm.
          - Some programs, some methods and some algorithm are written by somebody.
          - Hence this algorithm is written by Seed (rand.Seed())
          - We have to change the number in Seed so it will give us random number. But this is not something we want to achieve.
        - How we can achive the random number using math/rand?
          - The only thing which keep on changing is time (no matter what you do).
          - Now, it is much guranteed that the Seed (rand.Seed()) is being initialized by a truely random number (every single time) and we are expected to get the random number.
        - Syntax
          - rand.Seed(time.Now().UnixNano())
          - fmt.Println(rand.Intn(5))
    - crypto/rand
      - this packages gives us surety about randomness of number because it goverened by a cryptograpghy algorithm.
      - We can use this package to generate secure information for example token etc.
        - Syntax
          - randomNum, _ := rand.Int(rand.Reader(), big.NewInt(5))
          - fmt.Println(randomNum)
- time
  - we need to use time package to use and format time in golang
  - time.Now()
  - Syntax
    - presentTime := time.Now()
    - fmt.Println(presentTime)
  - Formatting time:
    - to format the time, we need to use 'Format' method.
      - fmt.Println(presentTime.Format("2006-01-02 15:04:05 Monday"))
      - 2006-01-02 15:04:05 Monday ->
        - 2006 -> will always represent to current year (in output)
        - 01 -> will represent to Month
        - 02 -> will represent to Date
        - Monday -> will represent to Current Day
        - Output -> 2022-01-13 Thursday
        - 15 -> current Hour
        - 04 -> minute
        - 05 -> second
